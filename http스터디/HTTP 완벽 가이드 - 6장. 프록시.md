## HTTP 완벽 가이드 - 6장. 프록시

웹 프록시 : 간단히 말해서 **클라이언트 - 서버 사이에 위치해 HTTP 메시지를 정리하는 역할**

아래 목록을 설명함.

> HTTP 프록시 서버는 웹 서버이면서 웹 클라이언트이다.(표현하자면)
> -> 중간에서 양쪽에게 좋은 서비스를 제공해주는 역할을 하는 것이다.



#### <u>개인 프록시 / 공용 프록시</u>

- **개인 프록시** : 하나의 클라이언트가 독점적으로 사용하는 프록시


- **공용 프록시** : 여러 클라이언트가 함께 사용하는 프록시 -> 대부분임

  중앙 집중형 프록시를 사용하는 것이 여러 사용자들의 공통된 요청에서 이득을 취할 수 있어 유리 (캐싱같이)



#### <u>프록시 vs 게이트웨이</u>

- **프록시** : **같은 프로토콜** 사용하는 둘 이상을 연결
- **게이트웨이** : **서로 다른 프로토콜**을 사용하는 둘 이상을 연결 -> 마치 프로토콜 변환기

![스크린샷 2018-07-20 오전 12.37.09](/Users/user/Desktop/http스터디/스크린샷 2018-07-20 오전 12.37.09.png)

​	(a) http 프로토콜로만 통신하는 http프록시
​	(b) http 를 pop 트랜잭션으로 변환해줌. http통해 이메일 읽을 수 있게 해줌.


그러나 상용 프록시 서버는 SSL 보안 프로토콜, 방화벽, FTP 접근, web app에 대한 지원을 하기 위해서 **게이트웨이 기능을 구현**한다.



#### <u>프록시의 사용 목적</u>

프록시 서버는 모든 HTTP 트래픽을 관리할 수 있음 -> 유용한 웹 서비스 구현 위해 트래픽 감시 및 수정한다.


1. **어린이 필터**

   악성 콘텐츠 식별하고 접근 제한 위한 **필터링 기능** 제공
   ​

2. **접근 제어**

   웹 **리소스에 대한 단일한 접근 제어 구현**하고 감사 추적위해 사용할 수 있음.

   <u>각 웹 서버들에 대한 접근 제어를 수시로 갱신할 필요 x</u> -> <u>중앙 프록시 서버에서 접근 제어 설정 가능</u>
   ​

3. **보안 방화벽**

   application 레벨의 프로토콜 흐름을 네트워크의 한 지점에서 통제 가능
   ​

4. **웹 캐시**

   클라이언트의 요청 내용과 응답을 **캐싱해두고 동일한 요청이 들어오면 저장된 콘텐츠를 보내주는** 역할
   ​

5. **대리 프록시(Surrogate, reverse proxy)**

   웹 서버인것처럼 위장해서 실제 웹 서버의 요청을 받지만, 응답을 주기 위해 실제 웹서버나 다른 프록시 서버와 통신함.

   웹 서버의 부하를 줄여주기 위해 분산 네트워크(로드 밸런싱)와 보안을 위해 사용됨
   ​

6. **콘텐츠 라우터**

   인터넷 트래픽 조건, 컨텐츠 종류에 따라서 **요청을 특정 웹 서버로 유도하는 라우터로 동작**할 수 있음. -> 사용자들에게 제공할 여러  서비스 구현에 사용

   ![스크린샷 2018-07-20 오후 5.33.53](/Users/user/Desktop/http스터디/스크린샷 2018-07-20 오후 5.33.53.png)
   ​

7. **트랜스코더**

   콘텐츠를 클라이언트에게 전달하기 전에 **본문 포맷을 수정할 수 있음**. 

   -> <u>상대적으로 단순한 데이터 인코딩 방식을 '트랜스 코딩' 이라고 부름</u>.(무손실 압축과 같은)

   예) GIF 이미지를 JPG 이미지로 변환할 수 있고, 크기, 강도, 압축 등 변환 + 텍스트 파일 특정 언어로 변환
   ​

8. **익명화 프록시**

   HTTP 메세지에서 IP주소, From헤더, Referer헤더, 쿠키 등을 제거하여 **개인 정보 보호 및 익명성 보장에 사용**.
   -> 그러나 클라이언트 식별 정보를 무조건적으로 제거하면 안됨.



#### <u>프록시 서버 배치</u>

어떻게 사용할지에 따라서 어디든 배치 가능하다. - 아래는 <u>위치에 따른 분류</u>

1. **출구 프록시**(Egress proxy) : 로컬 네트워크와 외부 네트워크를 오가는 트랙픽을 제어하기 위해 로컬 네트워크의 출구에 배치 -> 보안, 성능 개선, 필터링

2. **접근(입구) 프록시** : 클라이언트의 요청들을 종합적으로 처리하기 위해 ISP(internet service provider) 접근 지점에 위치함 -> 다운로드 속도 개선, 캐싱

3. **대리 프록시(reverse proxy)** : 웹 서버 바로 앞에 위치해 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청함 -> 일반적으로 웹 서버의 이름, ip주소로 가장하기 떄문에 이 프록시로 요청들이 들어옴

4. **네트워크 교환 프록시** : <u>인터넷 피어링 교환 지점</u>에 놓이는 것.

   > 피어링은 [인터넷 서비스 제공업체](http://www.terms.co.kr/ISP.htm)(isp)들간 [트래픽](http://www.terms.co.kr/traffic.htm) 교환에 관한 합의이다. 자사의 [백본](http://www.terms.co.kr/backbone.htm)망을 가지고 있는 대형 ISP들은 다른 대형 ISP들의 트래픽이 그들의 백본 상에서 교환될 수 있도록 허용. 즉, <u>ISP간 네트워크 연결 및 교환</u>하는 것.



#### <u>프록시 계층</u>

프록시들은 **연쇄적인 구조**를 가지는 '프록시 계층'를 구성 가능함

**서버 쪽에 가까우면 부모, 클라이언트 쪽에 가까우면 자식**으로 불림

![스크린샷 2018-07-22 오전 11.59.26](/Users/user/Desktop/http스터디/스크린샷 2018-07-22 오전 11.59.26.png)

- 위의 계층은 언제나 정적

  1은 언제나 메시지를 2로, 2는 언제나 3으로

![스크린샷 2018-07-22 오후 12.09.40](/Users/user/Desktop/http스터디/스크린샷 2018-07-22 오후 12.09.40.png)

- 동적인 계층도 존재

  - 콘텐츠 분산 위해 돈을 지불한 웹 서버면, 프록시는 **요청을 캐시 서버에 보내서 캐시된 객체 반환**해줌
  - 특정 종류의 요청일 때(이미지 같은) 프록시는 그러한 **요청에 특화된 압축 프록시에** 보내어 클라이언트가 빠르게 다운로드 가능하게 함

  이와 같이 URI의 종류, 제공하는 서비스, 지리적인 위치, 부모 프록시들의 작업량 등에 따라서 **부모 프록시를 찾는 라우팅 로직이 달라진다.**
  ​

#### <u>프록시의 트래픽 처리</u>

**어떻게 HTTP 트래픽이 프록시로 향하는 길을 찾아낼 수 있게 설정하는지** 설명 - 4가지 방법

1. 클라이언트를 수정 - 일반적으로 웹 클라이언트들(브라우저)은 수동, 자동 프록시 설정을 지원함
   -> 의도적으로 원 서버가 아닌 프록시 서버에 요청을 보냄
2. 네트워크를 수정 - 스위칭, 라우팅 장치를 사용해 네트워크 인프라를 가로채서 트래픽을 프록시로 가게 조정함( = 인터셉트 프록시)
3. DNS 테이블를 수정 - 수동으로 DNS 테이블을 편집하거나, 적절한 프록시를 찾아주는 동적 DNS서버를 이용해서 요청들이 대리 프록시(reverse proxy)로 갈 수 있게 조정
4. 웹 서버를 수정 - 리다이렉션 명령(305)을 클라이언트에 돌려줘서 요청을 프록시로 리다이렉트하게 설정



#### <u>클라이언트 프록시 설정</u>

위 1번의 방식에 대한 설정 방법 설명

- 수동설정 - 프록시 사용하겠음

- 브라우저 기본 설정 - 디폴트 설정

- 자동 설정(Proxy auto-configuration - PAC) - 자바스크립트로 작성된 프록시 자동 설정 파일에 대한 uri를 제공 

  ```javascript
  function FindProxyForUrl(url, host){
      if(url.substring(0,5) == "http:"){
          return "PROXY http-proxy.mydomain.com:8080";
      } else if(url.substring(0,4) == "ftp:"){
          return "PROXY ftp-proxy.mydomain.com:8080";
      } else{
          return "DIRECT";
      }
  }
  ```

  위와 같이 프록시 서버 사용 유무나 어떤 프록시 사용?에대한 판단 위해 자바스크립트 파일 실행

- WPAD 프록시 발견 - Web Poxy Autodiscovery Protocol로, 대부분의 브라우저가 자동설정 파일(3번의 PAC 파일)을 다운받는 '설정 서버'를 자동으로 찾을 수 있도록 제공함 -> 가져온 PAC파일 실행

-> PAC에 대한 설명은 20장에 자세히 나옴



#### <u>프록시 요청의 미묘한 특징들</u>

1. 프록시 URI vs. 서버 URI

   -> 태초의 http 설계를 가상 호스팅, 프록시에 대한 고려없이 **단일한 서버와 통신한다고 가정하고 했음.**

   -> 불필요한 정보 발송 피하기 위해서 스킴, 호스트, 포트번호 생략하는 **부분 URI 적용**됨.

   -> 프록시가 생기면서 위 **정보들이 필요해졌음**(목적지 서버 이름, 스킴)

   -> 그래서 **웹서버로 요청은 부분 URI** `GET /index.html HTTP/1.0  User-Agent: SuperBrowserv1.3`, **프록시로 요청은 완전한 URI** `GET http://www.marys-antiques.com/index.html HTTP/1.0  User-Agent: SuperBrowserv1.3` 보내는 것으로 함.

   -> 가상 호스팅에서도 동일한 문제가 발생했고, 호스트와 포트에 대한 정보 담긴 Host헤더를 요구하는 방식으로 해결함.
   ​

2. 대리 프록시(reverse proxy), 인터셉트 프록시의 경우 예외적

   위와 같은 프록시는 **클라이언트가 실제 웹 서버와 통신하고 있다고 생각**하고 **부분 URI를 보내게 된다**.

   -> 프록시에 **실제 서버의 주소와 포트 번호 설정**되어 있음

   -> 만약 원 서버를 알아낼 수 있는 충분한 정보를 갖지 못하면 에러 메세지를 보냄(보통 host헤더 지원하는 브라우저로의 업데이트 요구하는 메시지)



#### <u>전송 중 URI 변경</u>

몇몇 프록시는 URI를 다음 홉으로 보내기 전에 **표준 형식으로 정규화하는 과정**을 거침.

이런 과정도 프록시 서버는 프로토콜을 엄격하게 준수한다기보다  **가능한 관대하게** 해야함.

-> 기존에 잘 동작하던 기능들을 심각하게 망쳐버릴 수 있기 때문에

(예. 인터셉트 프록시가 URI 전달시 경로를 수정 못하게 함.)



#### <u>URI 클라이언트 자동확장과 호스트명 분석(HostName Resolution)</u>

브라우저는 요청 URI를 분석하여 확장하는 기능이 있다. -> 책에 자세한 설명

기본적인 예. www.를 생략하고 naver.com만 치면 https://www. prefix를 붙여준다.

![스크린샷 2018-07-22 오후 1.18.17](/Users/user/Desktop/http스터디/스크린샷 2018-07-22 오후 1.18.17.png)

프록시를 사용하게 되면 죽은 서버의 DNS 분석에 대한 <u>장애 허용</u>을 지원해줘야함.

> 장애 허용(fault tolerance) : 장애 발생해도 정상적 혹은 부분적으로 이용 가능하게 할 수 있는 것

-> 브라우저에서 제공하는 수준의 장애 허용을 프록시도 제공해줘야함.

-> 그러면 실제 웹 서버와 통신할 준비가 되었을 때 해당 ip주소의 서버가 다운되었다는 것을 알고 다른 ip주소로 시도하게 끔 할 수 있음.



#### <u>메세지 추적</u>

프록시 사용이 많아지면서 IP 패킷 흐름 추적 못지 않게 프록시들을 넘나드는 메시지 흐름을 추적하고 문제점을 찾아내는 것이 중요해짐.

- ##### **Via헤더**

  메시지가 지나는 각 중간 **노드(프록시, 게이트웨이)의 정보를 나열**

  ```
  Via: 프로토콜이름/버전 노드이름(호스트:포트번호(선택)) 노드 코멘트(선택) , ... , ...

  ','로 구분하여 각 경유지(waypoint-프록시 서버나 게이트웨이 홉) 작성, http의 경우 프로토콜 이름 생략 가능, 포트번호 생략시 프로토콜의 기본 포트번호로 간주, 요청과 응답의 Via헤더는 언제나 반대

  예) Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
  메시지가 두 개의 프록시 지났음을 알려줌(각각 http 1.1, 1.0 프로토콜 사용하는 프록시)
  ```

  Via 헤더 필드는 메시지의 전달 추적, 메시지나 네트워크 상의 <u>라우팅 루프</u> 진단, 모든 메시지 발송자들의 프로토콜 다루는 능력 알아보기 위해 사용됨

  > 라우팅 루프(routing loop) : 패킷, 메시지가 목적지를 찾지 못하고 끊임없이 순환(Looping)하는 현상

  어떤 프록시들은 비 http프로토콜을 사용할 수 있고(게이트웨이 기능 같은), 이러한 **프로토콜 변환도 기록**하게 된다.

  -> 프록시들의 연쇄구조에서 프로토콜 능력과 변환이 있었는지 알게됨

  ```
  //http 응답 메세지
  ...
  Via: FTP/1.0 proxy.irense-isp.net (Traffic-Server/5.0.1-17882 [cMsf])
  ...
  ```

  Via 필드에 들어있는 **정보 노출에 따른 보안 이슈**는 호스트 이름을 적당한 가명으로 교체한다거나, 정렬된 일련의 Via 경유지들(프로토콜이 동일한)을 하나로 합칠 수 있음.

  ```
  Via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com

  Via: 1.0 foo, 1.1 concealed-suff
  ```

  ​

- ##### **Server 헤더**

  **웹 서버에 의해 사용되는 소프트웨어**를 알려줌 - 원 서버를 위해 존재

  ```
  Server: Apache/1.3.14 (Unix) PHP/4.0.4
  Server: NetScape-Enterprise/4.1
  Server: Microsoft-IIS/5.0
  ```



- ##### TRACE 메서드

  프록시 서버는 메시지가 전달될 때 헤더추가, 변경, 삭제 또는 본문 형식을 변경하는 등 메시지를 바꿀 수 있음.

  따라서 **메시지의 내용이 어떻게 변하는지 편리하게 관찰**할 방법이 필요.

  -> TRACE 메서드가 이런  **프록시 흐름을 디버깅하는데 매우 유용**하게 사용됨.

  -> <u>주석에 불행히도 널리 구현되지 않았다고 함</u>

  ​

  TRACE 요청(TRACE 메시지)가 목적지 서버에 도착하면 전체 TRACE **요청 메시지를 HTTP 응답메시지 본문에 포함시켜 그대로 돌려보냄.**

  그럼 응답이 오면 클라이언트는 **서버가 받은 메시지랑 그 메시지가 지나간 프록시들의 목록을 검사**할 수 있음.

  cf. *TRACE 메시지의 content-type은 message/http*

  ​

  - Max-Fowards값(헤더 필드)을 설정해서 **전달될 홉의 횟수를 제한**할 수 있음

    ![스크린샷 2018-07-22 오후 2.21.30](/Users/user/Desktop/http스터디/스크린샷 2018-07-22 오후 2.21.30.png)



#### <u>프록시 인증</u>

프록시는 **접근 제어 장치로서** 제공될 수 있고, **유효한 접근 권한이 없으면 콘텐츠에 대한 요청을 차단하는 프록시 인증 메커니즘**을 정의하고 있음.

1. 제한된 콘첸츠 접근 시, 자격 요구하는 '407 Proxy Authorization Required' status code랑 Proxy-Authenticate 헤더 필드를 같이 반환한다.
2. 클라이언트가 407 받게 되면, 사용자에게 물어보든, 로컬 데이터베이스 확인하든 해서 자격 수집한다.
3. 요구되는 자격을 Proxy-Authentication 헤더 필드에 담아서 다시 요청 보낸다
4. 자격 유효 시 프록시는 원래 요청을 연쇄구조 따라 통과 시킨다. 아니면 407 응답 보냄

-> 그러나 프록시 연쇄 상에 여러개가 인증에 참여하면 잘 동작하지 않음



#### <u>프록시 상호운용성</u>(호환성)

클라이언트, 서버, 프록시는 http명세의 여러 버전에 따라 다양한 벤더에 의해 만들어짐.

각각 여러 가지 기능을 지원하고 버그들을 가지고 있기 때문에 프록시 서버는 이런 가운데서 클라이언트와 서버 사이의 중개자 역할을 잘해야함.

- 지원하지 않는 헤더 필드나 메서드는 프록시가 이해 못해도 **그대로 전달해주어야**함.

  같은 이름의 헤더 필드가 여러개 있는 경우에도 **순서도 반드시 유지해야**함.

- **OPTIONS 메서드**를 사용해 서버의 **특정 리소스가 어떤 기능(메소드같은)을 지원하는지** 클라이언트 나 프록시에게 알려줄 수 있음.

  -> 서로 다른 기능 수준의 서버와 프록시가 더 쉽게 상호작용할 수 있도록 **클라이언트가 서버 능력을 먼저 알아내는 것.**

  ![스크린샷 2018-07-22 오후 2.37.05](/Users/user/Desktop/http스터디/스크린샷 2018-07-22 오후 2.37.05.png)

  만약 * 이면 서버 전체의 능력에 대해 묻는 것이고,

  ```
  OPTIONS http://www.joes-hardware.com/index.html HTTP/1.1
  ```

  위와 같다면 특정 리소스에 대해 가능한 기능을 묻는 것

  <u>HTTP/1.1에서는 Allow 헤더만을 제공함 - 어떤 메서드 지원되는지</u>

  ​

  ​













1. http proxy vs. web gateway
2. 사용 목적
3. 실제 배치 + 트래픽이 어떻게 프록시 서버로 가는지
4. 브라우저에서 사용하기 위한 설정법
5. http proxy 요청 vs. 서버 요청 + 프록시가 어떻게 브라우저 동작 바꾸는지
6. via 헤더와 TRACE 메서드를 이용한 기록 방법 - 프록시 흐름 관리